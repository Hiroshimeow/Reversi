(defconstant Board-Size 8)
(defconstant Board-Dimensions (list Board-Size Board-Size))
(defconstant Board-Sente 1)
(defconstant Board-Gote -1)
(defconstant Board-Empty 0)
(defconstant Board-Sente-String "*")
(defconstant Board-Gote-String "o")
(defconstant Board-Empty-String "-")

(defconstant Board-Initial               
  #2A((0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 -1 1 0 0 0)
      (0 0 0 1 -1 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0)))

(defconstant Board-Point 
   #2A((30 -12 0.1 -0.9 -0.9 0.1 -12 30) (-12 -15 -3 -3 -3 -3 -15 -12) (0.1 -3 0 -1 -1 0 -3 0.1) (-0.9 -3 -1 -1 -1 -1 -3 -0.9)
       (-0.9 -3 -1 -1 -1 -1 -3 -0.9) (0.1 -3 0 -1 -1 0 -3 0.1) (-12 -15 -3 -3 -3 -3 -15 -12) (30 -12 0.1 -0.9 -0.9 0.1 -12 30)))
       (defun change-turn (turn)
  (cond ((equal turn Board-Sente) Board-Gote)
	(t Board-Sente)))
    (defun symbol-turn (turn)
  (cond ((equal turn Board-Sente) Board-Sente-String)
	((equal turn Board-Gote)  Board-Gote-String)
	(t Board-Empty-String)))

(defun make-board () (make-array Board-Dimensions))
(defun ref-board (board row col)
  (aref board row col))
(defun set-board (board row col turn)
  (setf (aref board row col) turn))
  (defun copy-board (board)
  (let ((new-board (make-board)))
    (dotimes (row Board-Size new-board)
      (dotimes (col Board-Size)
	(set-board new-board row col (ref-board board row col))))))
    (defun print-board (board)
    
    (format  t "R/C 0 1 2 3 4 5 6 7~%")
    (dotimes (row Board-Size )
      (format t "  ~d" row)
      (dotimes (col Board-Size)
	(format t " ~A" (symbol-turn (ref-board board row col))))
      (cond ((equal row  Board-Size) t)
	    (t (format t "~%")))))

(defconstant Board-Directions  
  '((0 1) (1 1) (1 0) (1 -1) (0 -1) (-1 -1) (-1 0) (-1 1)))

(defun sample-scan (board row0 col0 row-inc col-inc)  
  (do ((row row0 (+ row row-inc))
       (col col0 (+ col col-inc))
       (length 0 (1+ length)))
      ((or (< row 0) (= row Board-Size) (< col 0) (= col Board-Size)
	   (equal (ref-board board row col) Board-Empty))
       length)))

(defun board-scan (board row0 col0 row-inc col-inc turn)
  (do ((row (+ row0 row-inc) (+ row row-inc))
       (col (+ col0 col-inc) (+ col col-inc))
       (length 0 (1+ length)))
      ((or (< row 0) (= row Board-Size) (< col 0) (= col Board-Size)
	   (equal (ref-board board row col) Board-Empty))
	   0)
      (cond((equal (ref-board board row col) turn) (return length))
	   (t t))))

(defun board-movable (board row col turn)
  (and (equal (ref-board board row col) Board-Empty)
       (dolist (dir Board-Directions nil)
	 (cond ((> (board-scan board row col (car dir) (cadr dir) turn) 0)
		(return t))))))

(defun board-movable-any (board turn)
  (block roro
   (dotimes (row Board-Size nil)
    (dotimes (col Board-Size)
      (cond ((equal (board-movable board row col turn) t) (return-from roro  t))
	    (t t))
      ))
   ))
  
  (defun othello-by-human ()
  (do ((board (copy-board Board-Initial))
       (turn Board-Sente (change-turn turn))
       (count 1 (1+ count))
       state)
      ((numberp (setq state (board-state board turn)))
       (game-result board state))
      (print-board board)
      (cond ((equal state 'pass)
	     (format t "(~A) Pass.~%" count))
	    (t (play-by-human board turn count)))))
        (defun board-state (board turn)
  (cond ((equal (board-movable-any board turn) t) nil)
	((equal (board-movable-any board (change-turn turn)) t) 'pass)
	(t (board-eval board))))
    (defun board-eval (board)
  (let ((count 0) (ste 0))
   (dotimes (row Board-Size (/ ste count))
      (dotimes (col Board-Size)
	(setq ste (+ ste (ref-board board row col)))
	(cond ((not (equal 0 (ref-board board row col)))
	       (setq count (1+ count)))
	      (t t)))))
	      
            )

(defun game-result (board state)
  (print-board board)
  (format t "~%")
  (cond ((< 0 state)
	 (format t "Game Won by * ~%"))
	((> 0 state)
	 (format t "Game Won by o ~%"))
	(t (format t "Drow ~%")))
  (let ((sco 0) (gco 0))
   (dotimes (row Board-Size (format t "Score is ~d - ~d" sco gco))
      (dotimes (col Board-Size)
	(cond ((equal 1 (ref-board board row col))
	       (setq sco (1+ sco)))
	      ((equal -1 (ref-board board row col))
	       (setq gco (1+ gco)))
	      (t t))))))
          (defun play-by-human (board turn count)
  (format t "(~A) Enter row and col for ~A: " count (symbol-turn turn))
  (do ((row (read) (read))
       (col (read) (read)))
      ((and (board-number-check row col)
	    (board-movable board row col turn))
       (board-move board row col turn))
      (format t "Re-enter row and col for ~A: " (symbol-turn turn))))

(defun board-move (board row col turn)
  (set-board board row col turn)
  (dolist (dir Board-Directions board)
    (let((row0 row) (col0 col))
      (dotimes (count (board-scan board row0 col0 (car dir) (cadr dir) turn))
	(setq row0 (+ row0 (car dir)))
	(setq col0 (+ col0 (cadr dir)))
        (setf (aref board row0 col0) turn)))))
    
  
  (defun board-number-check (row col)
  (cond ((not (or (numberp row) (numberp col))) nil)
	((or (> 0 row) (> row (1- Board-Size))) nil)
	((or (> 0 row) (> col (1- Board-Size))) nil)
	(t t)))
	

(defstruct node
  row col 
  board 
  val 
 )

(defun eval-node (node turn count) (cond ((< count 25)
					  (+ (board-eval2 (node-board node) 3) (board-eval3 (node-board node) turn 20) (board-eval4 (node-board node) 100) (board-eval5 (node-board node) turn 500)))
					 ((< count 40)
					  (+ (board-eval2 (node-board node) 3) (board-eval3 (node-board node) turn 40) (board-eval4 (node-board node) 100)))
					 ((< count 60)
					  (+ (board-eval2 (node-board node) 3) (board-eval3 (node-board node) turn 20) (board-eval4 (node-board node) 100)))
					 (t (board-eval (node-board node)))
					 )
       )
				       
                       (defun expand-node (node turn)
  (let((node-list nil) (board nil) (new-node (make-node)))
    (dotimes (row Board-Size (reverse node-list))
      (dotimes (col Board-Size)
	(cond((equal (board-movable (node-board node) row col turn) t)
	      (setq board (copy-board (node-board node)))
	      (board-move board row col turn)
	      (setq new-node (make-node
			      :row row
			      :col col
			      :board board))
	      (setq node-list (cons new-node node-list)))
	     (t t))))))
	
    (defun node-state (node turn count)
  (board-state (node-board node) turn))

(defun minimax (node turn count depth)
  (let ((state (node-state node turn count)))
    
    (cond ((numberp state) (setf (node-val node) state) node)
	  ((zerop depth) (setf (node-val node) (eval-node node turn count)) node)
	  ((equal state 'pass) (minimax node (change-turn turn) count depth))
	  (t (minimax-children (expand-node node turn) turn count depth)))))
      (defun minimax-children (children turn count depth)
  (let ((new-turn (change-turn turn))
	(new-depth (1- depth))
	(new-count (1+ count))
	(v 0))
    (do ((val nil) (result-node nil))
	((null children) result-node)
	(setq v (node-val (minimax (car children) new-turn new-count new-depth)))
	(cond ((or (null val)
		   (and (equal turn Board-Sente) (> v val))
		   (and (equal turn Board-Gote) (< v val)))
	       (setq val v)
	       (setq result-node (make-node
				  :row (node-row (car children))
				  :col (node-col (car children))
				  :board (node-board (car children))
				  :val v))))
	(setq children (cdr children)))))
    (defun othello (sente-gote yomi-depth)
  (do ((board (copy-board Board-Initial))
       (turn Board-Sente (change-turn turn))
       (count 1 (1+ count))
       state)
      ((numberp (setq state (board-state board turn)))
       (game-result board state))
      (print-board board)
      (cond ((equal state 'pass)
	     (format t "(~A) Pass. ~%" count) (setq count (1- count)))
	    ((or (equal sente-gote Board-Empty) (equal turn sente-gote))
	     (play-by-machine board turn count yomi-depth))
	    (t (play-by-human board turn count)))))

(defun play-by-machine (board turn count depth)
  (let((node (make-node)))
    
    (setq node (alpha-beta (make-node :board board) turn count depth nil nil))
  
    (board-move board (node-row node) (node-col node) turn)
    
    (format t "(~A) My move is ~d ~d." count (node-row node) (node-col node)))
  )
  (defun alpha-beta (node turn count depth alpha beta)
  (let ((state (node-state node turn count)))
    
    (cond ((numberp state) (setf (node-val node) state) node)
	  ((zerop depth) (setf (node-val node) (eval-node node turn count)) node)
	  ((equal state 'pass) (alpha-beta node (change-turn turn) count depth alpha beta))
	  (t (alpha-beta-children (expand-node node turn) turn count depth alpha beta)))))
      (defun alpha-beta-children (children turn count depth alpha beta)
  (let ((new-turn (change-turn turn))
	(new-depth (1- depth))
	(new-count (1+ count))
	(v 0)
	(alpha0 alpha)
	(beta0 beta)
	)
    (do ((val nil) (result-node nil))
	((or (and (numberp alpha0) (numberp beta0) (>= alpha0 beta0)) (null children)) result-node)
	(setq v (node-val (alpha-beta (car children) new-turn new-count new-depth alpha0 beta0)))
	(cond ((or (null val)
		   (and (equal turn Board-Sente) (> v val))
		   (and (equal turn Board-Gote) (< v val)))
	       (setq val v)
	       (setq result-node (make-node
				  :row (node-row (car children))
				  :col (node-col (car children))
				  :board (node-board (car children))
				  :val v))))
                  	(cond ((equal turn Board-Sente)
	       (cond ((or (null alpha0)
			  (> v alpha0))
		      (setq alpha0 v))))
	       
	      
	      ((equal turn Board-Gote)
	       (cond ((or (null beta0)
			  (< v beta0))
		      (setq beta0 v))))
	      )
	       
	(setq children (cdr children)))))
    (defun board-eval2 (board omomi)
  (let ((count 0))
   (dotimes (row Board-Size count)
      (dotimes (col Board-Size)
	(cond ((equal  (ref-board board row col) Board-Empty)
	       (setq count (+ count (* (ref-board Board-Point row col) Board-Empty))))
	      ((equal  (ref-board board row col) Board-Sente)
	       (setq count (+ count (* (ref-board Board-Point row col) Board-Sente))))
	      ((equal  (ref-board board row col) Board-Empty)
	       (setq count (+ count (* (ref-board Board-Point row col) Board-Gote))))
	      
	      )
	      )
      )
   (setq count (* count omomi))
   )
  )

(defun board-eval3 (board turn omomi)
  (let ((count 0))
    (dotimes (row Board-Size count)
      (dotimes (col Board-Size)
	(cond((board-movable board row col turn)
	      (setq count (+ count (* turn (+ (ref-board Board-Point row col) omomi))))
	      )
	     )
	)
      )
    )
  )

(defun kakutei-scan (board row0 col0 row-inc col-inc turn)
  (do ((row row0 (+ row row-inc))
       (col col0 (+ col col-inc))
       (length 0 (+ turn length)))
      ((or (< row 0) (= row Board-Size) (< col 0) (= col Board-Size)
	   (not (equal (ref-board board row col) turn)))
       length)))
       (defun board-eval4 (board omomi)
  (let ((count 0))
     (cond ((not (equal (ref-board board 0 0) Board-Empty))
	    (setq count (+ count (kakutei-scan board 0 0 1 0 (ref-board board 0 0)) (kakutei-scan board 0 0 0 1 (ref-board board 0 0))))))
     (cond ((not (equal (ref-board board 7 7) Board-Empty))
	    (setq count (+ count (kakutei-scan board 7 7 0 -1 (ref-board board 7 7)) (kakutei-scan board 7 7 -1 0 (ref-board board 7 7))))))
     (cond ((not (equal (ref-board board 0 7) Board-Empty))
	    (setq count (+ count (kakutei-scan board 0 7 0 -1 (ref-board board 0 7)) (kakutei-scan board 0 7 1 0 (ref-board board 0 7))))))
     (cond ((not (equal (ref-board board 7 0) Board-Empty))
	    (setq count (+ count (kakutei-scan board 7 0 -1 0 (ref-board board 7 0)) (kakutei-scan board 7 0 0 1 (ref-board board 7 0))))))
     (setq count (* omomi count))))
     (defun board-eval5 (board turn omomi)
  (let ((count 0))
     (cond ((not (and (equal (ref-board board 1 1) turn) (equal (ref-board board 0 0) Board-Empty)))
	    (setq count (+ count (* turn -1)))))
     (cond ((not (and (equal (ref-board board 6 6) turn) (equal (ref-board board 7 7) Board-Empty)))
	    (setq count (+ count (* turn -1)))))
     (cond ((not (and (equal (ref-board board 1 6) turn) (equal (ref-board board 0 7) Board-Empty)))
	    (setq count (+ count (* turn -1)))))
     (cond ((not (and (equal (ref-board board 6 1) turn) (equal (ref-board board 7 0) Board-Empty)))
	    (setq count (+ count (* turn -1)))))
     (setq count (* omomi count))))
	   
       (defvar out-filename nil)
(defvar lock-out-filename nil)
(defvar in-filename nil)
(defvar lock-in-filename nil)
(defun read-board-from-file (board)
  (let ((eos (cons nil nil)) hand)
    (do ()
	((and (probe-file in-filename) (not (probe-file lock-in-filename))))
        (sleep 1))
    (with-open-file (i-file in-filename)
	(dotimes (row Board-Size)
	    (dotimes (col Board-Size)
		(setq hand (read i-file nil eos))
		(cond ((eq hand eos)
	           (set-board board 0 0 nil)
		   (return-from read-board-from-file board)))
		(set-board board row col hand))))
    (delete-file in-filename)))

(defun write-move-to-file (row col)
  (with-open-file (o-file lock-out-filename :direction :output)
     (print 'lock o-file))
  (with-open-file (o-file out-filename :direction :output)
     (format o-file "~A ~A" row col))
  (delete-file lock-out-filename))

(defconstant Owner "g20078")
(defun initialize (sente-gote)
  (let ((saki-ato (if (equal sente-gote Board-Sente) "saki" "ato")))
    (setq out-filename
	  (format nil "/tmp/te.~A.~A" Owner saki-ato))
    (setq lock-out-filename
	  (format nil "/tmp/te.~A.~A.lock" Owner saki-ato))
    (setq in-filename
	  (format nil "/tmp/ban.~A.~A" Owner saki-ato))
    (setq lock-in-filename
	  (format nil "/tmp/ban.~A.~A.lock" Owner saki-ato))
))

(defun main-loop (sente-gote yomi-depth)
  (initialize sente-gote)
  (let ((board (make-board)) (turn sente-gote))
    (read-board-from-file board)
    (do ((count (cond ((equal turn board-Sente) 1) (t 2))
		(+ count 2))
	 (1st (ref-board board 0 0) (ref-board board 0 0))
	 (state (board-state board turn)) node)
	((and (/= 1st Board-Sente) (/= 1st Board-Gote) (/= 1st Board-Empty)))
	(setq state (board-state board turn))
	(cond ((or (equal state 'pass) (numberp state))
	       (write-move-to-file -1 0))
           	      ((< count 40) (setq node (alpha-beta (make-node :board board)
		                                    turn count
		                                    yomi-depth nil nil))
	       (write-move-to-file (node-row node) (node-col node)))
	      ((< count 50) (setq node (alpha-beta (make-node :board board)
		                                    turn count
		                                    (+ yomi-depth 1) nil nil))
	       (write-move-to-file (node-row node) (node-col node)))
	      (t (setq node (alpha-beta (make-node :board board)
		                                    turn count
		                                    (+ yomi-depth 2) nil nil))
	       (write-move-to-file (node-row node) (node-col node))))
	(read-board-from-file board)
 )))
		 
